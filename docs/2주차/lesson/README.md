
# 5. 인덱스

## 5.1 디스크 읽기 방식

### 랜덤 I/O VS. 순차 I/O

쿼리 튜닝으로 랜덤 I/O를 순차 I/O로 바꾸긴 쉽지 않고, 랜덤 I/O 자체를 줄이는 것이 목적이다.
(꼭 필요한 데이터만 읽는 것!)

## 5.2 인덱스란?

책의 색인처럼, DBMS에서 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능.

**Primary Key**

- 레코드의 대표 컬럼
- Not NULL & Unique

**Secondary Index**

- Unique VS. Non-Unique

## 5.3 B-Tree 인덱스

Binary가 아니라 Balanced → 자식 노드 개수가 **가변적**

컬럼 값을 변형시키지 않고 인덱싱

전문 검색 외 대부분 B-Tree를 사용한다.

### 5.3.1 구조 및 특성

루트 노드(인덱스 레코드, 자식 노드 주소) → 브랜치 노드 → 리프 노드(인덱스레코드, 레코드 주소)

데이터파일의 레코드는 임의 순서로 저장되어 있다.(레코드 삭제 후 재활용하기 때문)

레코드 주소는 DBMS에 따라 의미가 다르다. (InnoDB는 PK값 자체가 주소 역할)

### 5.3.2 인덱스 키 추가 및 삭제

새로운 값이 저장될 때, 리프 노드가 꽉차면 상위 브랜치 노드까지 처리해야해서 쓰기 작업이 오래걸린다.

처리 비용은 대략 레코드 저장이 1이면, 인덱스 하나 당 1.5 → 디스크 I/O 작업이 많음.

InnoDB는 인덱스 작업을 버퍼링 및 지연 처리 할 수 있다. → 추가/삭제 중 어느 것을 지연처리할 지 설정

**인덱스 삭제**

해당 리프 노드에 삭제 마킹

**인덱스 변경**

삭제 후 추가

**인덱스 키 검색**

트리 탐색

100% 일치 or 값의 앞부분 일치 검색에 사용

인덱스의 키값에 변형이 가해진 후 비교되는 경우, 빠른 검색 불가능

InnoDB는 UPDATE, DELETE 실행 시 적절한 인덱스가 없으면 불필요하게 많은 레코드를 잠가버림.

### 5.3.3 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

- 인덱스 키 값이 커지면 디스크 I/O 횟수가 늘어나고, 캐시 효율이 떨어진다.
- (InnoDB 기본 페이지 크기는 16KB, 보통 자식 노드는 인덱스 키 + 12 byte)

**B-Tree 깊이**

- 어차피 5 이상 깊어지지 않아서 딱히 중요하진 않음.

**선택도(기수성)**

- 중복이 적을 수록 빠르게 처리된다.

**읽어야 하는 레코드 수**

- 전체 건을 읽어서 필요없는 걸 버리는 게 나은지, 인덱스를 타서 읽어오는 게 나은지 선택해야 한다.
- 손익분기점? 전체 레코드의 20~25%를 넘어서면 전체를 읽는 게 낫다.
    - 기본적으로 옵티마이저가 알아서 해주긴 함.

### 5.3.4 데이터 읽기

**인덱스 레인지 스캔**

- 리프 노드를 찾은 후(시작 지점), 순서대로 읽는다.
- 검색 조건에 일치하는 레코드 수만큼 랜덤 I/O 실행

**인덱스 풀 스캔**

- 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우
- 쿼리가 인덱스에 명시된 칼럼만으로 조건을 처리할 수 있는 경우
- 일반적으로 인덱스를 생성하는 목적은 아니다.

**루스 인덱스 스캔**

- 중간 중간의 불필요한 인덱스 키값을 건너뛰는 방식

### 5.3.5 다중 칼럼(Multi-column) 인덱스

인덱스 내에서 각 컬럼의 순서가 중요하다.

### 5.3.6 정렬 및 스캔 방향

인덱스 생성 시 DESC 정렬은 불가능하다.(키워드 무시) → 필요하면 역으로 정렬해라???!

옵티마이저는 쿼리에 따라 인덱스를 정순으로 읽을지, 역순으로 읽을지 선택해 최적화해준다.

### 5.3.7 가용성과 효율성

- 쿼리 조건이 범위일 때, 자잘한 칼럼(ex. 사원번호)이 굵직한 컬럼(ex. 부서) 앞에 있으면 비효율적이다.
- `like '%some'`처럼 값의 앞부분이 고정되지 않으면 인덱스를 탈 수 없다.
- 선행 컬럼의 값을 모르고, 뒷 컬럼 값으로만 검색하면 비효율적이다.
- 사용할 수 없는 경우
    - Not Equal 비교(<>, NOT IN, NOT BETWEEN, IS NOT NULL)
    - Like '%어쩌구'
    - 스토어드 함수나 연산자로 인덱스 칼럼이 변형된 후 비교
    - NOT-DETERMINISTIC 속성이 스토어드 함수가 비교 조건에 사용된 경우
    - 데이터 타입이 서로 다른 비교(인덱스 컬럼 값을 변환해야 비교가 가능한 경우)
    - 문자열 데이터 타입의 콜레이션이 다른 경우 (utf8 vs euckr)
- MySQL은 NULL 값도 인덱스로 관리된다.

## 5.4 해시(Hash) 인덱스

메모리 기반의 테이블에서 주로 사용

- 인덱스 크기가 작고 검색이 빠르다.
- 동등비교 조건에 사용 가능
- 범위 비교, 부정형 비교(NOT)에서는 해시 인덱스 사용 불가능

## 5.5 R-Tree 인덱스

공간인덱스 ???!

## 5.6 Fractal-Tree 인덱스

다 좋은데 TokuDB만 사용 ????!

## 5.7 전문 검색(Full Text search) 인덱스

**구분자(Stopword) 기법**

문장 기호, 사용자 정의 문자 등으로 키워드를 분석해 인덱스 생성

내부적으로 B-Tree → 왼쪽부터 일치여부 검색

일치율이 높은 순서대로 정렬되는 것이 일반적

**N-그램 기법**

무조건 N글자로 잘라서 처리

구분자 단위로 쪼개지지 않은 문자열(검색어가 중간에 끼어있는)도 검색 가능

→ 전문검색 시에는 테이블을 쪼개서 사용하는 것이 낫다. (PK & Full Text 칼럼을 가진 별개의 테이블로)

## 5.9 클러스터링 인덱스

PK 값이 비슷한 레코드끼리 묶어서 저장

- PK 범위 검색 시 매우 빠름
- 테이블의 모든 보조 인덱스가 PK를 갖고 있어서 인덱스만으로 처리되는 경우가 많음
- 주의!
    - 클러스터 키값이 클 경우, 전체 인덱스의 크기가 커짐
    - 보조 인덱스 검색 시 PK로 한번 더 검색해야 함
    - INSERT 시 PK에 의해 저장 위치가 결정되어 처리 성능이 느림
    - PK 변경 시 레코드 DELETE → INSERT 작업이 필요하기 때문에 처리 성능이 느림
- Auto-Increment보다 업무적 칼럼이 좋다. ????!!!!

## **5.10. 유니크 인덱스**

유니크란 인덱스라기보다는 제약 조건에 가까움

### **유니크 인덱스 vs 보조 인덱스**

MySQL에서는 유니크 인덱스에 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데, 이 과정에서 **데드락**이 아주 빈번히 발생한다.

InnoDB 스토리지 엔진에서는 인덱스의 키의 저장을 버퍼링 하기 위해 **인서트 버퍼**가 사용되지만,
유니크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링 하지 못한다.

→ 유니크 인덱스는 일반 보조 인덱스보다 느리다.

### **유니크 인덱스 주의사항**

MySQL의 유니크 인덱스는 일반 다른 인덱스와 같은 역할을 하므로 중복해서 인덱스를 생성할 필요 없다.

꼭 필요하지 않다면 유니크하지 않은 보조 인덱스를 생성하는 방법도 한 번씩 고려해보자.

## 5.11 외래키

외래 키 제약이 설정되면, 자동으로 연관되는 테이블의 칼럼에 인덱스까지 생성된다.

외래 키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없다.

데드락 생성기!!

---

# 6. 실행 계획

### 6.1 **실행 계획이란?**

DBMS에서 쿼리를 최적으로 실행하기 위해 각 테이블의 데이터가 어떤 분포로 저장돼 있는지 **통계 정보**를 참조하며, 그러한 기본 데이터를 비교해 최적의 실행 계획을 수립하는 작업을 **옵티마이저가 담당**한다.

### **`EXPLAIN`**

MySQL에서는 **EXPLAIN**이라는 명령으로 쿼리의 실행 계획을 확인할 수 있다.

### 6.1.1 **쿼리 실행 절차**

1. **SQL 파싱 :** 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 SQL 파스 트리를 만든다. (SQL 파서라는 모듈로 처리)
2. SQL의 **파스 트리**를 확인하면서 **어떤 테이블**을 읽을지 **어떤 인덱스**를 이용할지 선택한다.
   이 단계가 완료되면 쿼리의 실행 계획이 만들어진다.
   → 옵티마이저에서 최적화 및 실행 계획
3. 스토리지 엔진으로부터 데이터를 가져온다.
   → 수립된 실행 계획대로 스토리지 엔진에 레코드를 읽어올 수 있도록 요청하고 (핸들러 요청),
   MySQL 엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

### 6.1.2 **옵티마이저의 종류**

- **비용 기반 최적화** (현재 대부분의 DBMS가 선택)
    - 쿼리를 처리하기 위한 여러 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 **예측된 통계 정보**를 이용해 각 실행 계획별 비용을 산출해, 최소 비용이 소요되는 처리 방식을 선택해 쿼리 실행.
- **규칙 기반 최적화**
    - 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선순위에 따라 실행 계획을 수립하는 방식.

### 6.1.3 **통계 정보**

**비용 기반 최적화**에서 가장 중요한 것은 **통계 정보**이다.

MySQL 또한 다른 DBMS와 같이 비용 기반의 최적화를 사용하지만 다른 DBMS보다 통계 정보는 그리 다양하지 않다.

또한 MySQL에서 통계 정보는 사용자가 알아채지 못하는 순간순간 자동으로 변경되기 때문에 상당히 **동적**인 편이다.

### **`ANALYZE`**

하지만 레코드 건수가 많지 않으면 통계 정보가 상당히 부정확한 경우가 많으므로 ANALYZE 명령을 이용해 강제적으로 통계 정보를 갱신해야 할 때 도 많다.

단, ANALYZE를 실행하는 동안 InnoDB 테이블은 읽기와 쓰기 모두 불가능하므로 서비스 도중에는 ANALYZE을 실행하지 않는 것이 좋다.

## 6.2 **실행 계획 분석**

### 6.2.1 **id 칼럼**

- 단위 SELECT 쿼리별로 부여되는 식별자 값.
- SELECT 문장은 하나인데 여러 개의 테이블이 조인되는 경우에는 id 값이 증가하지 않고 같은 id가 부여된다.

### 6.2.2 **select_type 칼럼**

**`SIMPLE`**

- UNION 이나 서브 쿼리를 사용하지 않는 단순한 SELECT 쿼리

**`PRIMARY`**

- UNION 이나 서브 쿼리가 포함된 SELECT 쿼리의 실행 계획에서 가장 바깥쪽에 있는 쿼리

**`UNION`**

- UNION으로 결합하는 단위 SELECT 쿼리 가운데 첫 번째를 제외한 두 번째 이후 단위 SELECT 쿼리

**`SUBQUERY`**

- FROM 절 이외에서 사용되는 서브 쿼리

**`DEPENDENT SUBQUERY`**

- 서브 쿼리가 바깥쪽 SELECT 쿼리에서 정의된 칼럼을 사용하는 경우

**`DERIVED`**

- 서브 쿼리가 FROM 절에 사용된 경우
- DERIVED는 단위 SELECT 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블을 생성. (파생 테이블)
- MySQL은 FROM 절에 사용된 서브 쿼리를 제대로 최적화하지 못할 때가 대부분임 => 조인으로 해결하는 것이 좋음

### 6.2.3 **table 칼럼**

- 테이블 기준으로 표시되며, 별칭이 부여된 경우에는 별칭이 표시.
- <> 테이블은 임시 테이블을 의미.

### 6.2.4 **type 칼럼**

- MySQL 서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지를 의미.
- **인덱스**를 사용해 레코드를 읽었는지, 테이블을 처음부터 끝까지 읽는 풀 테이블 스캔으로 읽었는지 등을 의미.
- 쿼리를 튜닝할 때 인덱스를 효율적으로 사용하는지 확인하는 것이 중요하므로 실행 계획에서 type 칼럼은 반드시 체크해야 할 중요 정보.

**`const`**

- 쿼리가 PK나 **유니크** 키 칼럼을 이용하는 WHERE 조건절을 가지고 있으며, 반드시 1건을 반환하는 쿼리의 처리 방식
- 다중 칼럼으로 인덱스의 일부 칼럼만 조건으로 사용할 때는 const 타입의 접근 방법을 사용할 수 없다. (ref로 표시됨)

**`eq_ref`**

- 여러 테이블이 **조인**되는 쿼리의 실행 계획에서만 표시됨.
- 조인에서 처음 읽은 테이블의 칼럼 값을, 그다음 읽어야 할 테이블의 PK나 유니크 키 칼럼의 검색 조건에 사용할 때

**`ref`**

- 인덱스의 종류와 관계없이 **동등 조건**으로 검색할 때
- ref 타입은 레코드가 반드시 1건이라는 보장이 없으므로 const나 eq_ref보다는 빠르지 않다.
  (하지만 동등 조건으로만 비교되므로 매우 빠른 레코드 조회 방법의 하나임)

→ **const, eq_ref, ref 정리**

- 세 가지 접근 방식은 모두 WHERE 조건절에 사용되는 비교 연산자가 동등 비교 연산자여야 한다.
- 세 가지 모두 인덱스의 분포도가 나쁘지 않다면 성능상의 문제를 일으키지 않는 **좋은** 접근 방법

**`unique_subquery`**

- WHERE 조건절에서 사용될 수 있는 IN 형태의 쿼리를 위한 접근 방식.
- 서브 쿼리에서 **중복되지 않은 유니크한 값만 반환할 때** 이 접근 방법을 사용.

**`index_subquery`**

- IN에서 subquery가 중복된 값을 반환할 수는 있지만, 중복된 값을 인덱스를 이용해 제거할 수 있을 때 index_subquery 접근 방식이 사용됨.

**`range`**

- **인덱스 레인지 스캔 형태**의 접근 방법
- **인덱스를 하나의 값이 아니라 범위로 검색하는 경우를 의미.**
- <, >, IS NULL, BETWEEN, IN, LIKE 등의 연산자를 이용해 인덱스를 검색할 때 사용된다.

→ cf) 보통 인덱스 레인지 스캔이라고 하면 const, ref, range라는 세 가지 접근 방법을 모두 묶어서 지칭한다.

**`index_merge`**

- 2개 이상의 인덱스를 이용해 각각의 검색 후, 그 결과를 **병합**하는 처리 방식.
- **다음과 같은 이유로 그다지 효율적이지 않음.**
    - 여러 인덱스를 읽어야 하므로 일반적으로 range 접근 방식보다 효율성이 떨어진다.
    - AND, OR 연산이 복잡하게 연결된 쿼리에서는 제대로 최적화되지 못할 때가 많음.
    - 전문 검색 인덱스를 사용하는 쿼리에서는 index_merge가 적용되지 않음.
    - index_merge 접근 방식으로 처리된 결과는 항상 2개 이상의 집합이 되기 때문에,
      그 두 집합의 교집합이나 합집합 또는 중복 제거와 같은 부가적인 작업이 더 필요하다.

**`index`**

- 인덱스를 처음부터 끝까지 읽는 **인덱스 풀 스캔.**
- 풀 테이블 스캔 방식과 비교했을때 비교하는 레코드 건수는 같지만, 인덱스는 일반적으로 데이터 파일 전체보다는 크기가 작아서 풀 테이블 스캔보다는 효율적이므로 풀 테이블 스캔보다는 빠르게 처리된다.
- **사용되는 경우**
    - 인덱스에 포함된 컬럼만으로 처리할 수 있는 쿼리인 경우 (**커버링 인덱스**)의 경우 사용되는 방식
    - 인덱스를 이용해 정렬이나 그룹핑 작업이 가능한 경우
- **개선 사항**
    - 인덱스 풀 스캔에서 **LIMIT 조건**을 사용하면 상당히 **효율**적인 쿼리를 만들 수 있다.
      (LIMIT 조건이 없거나 가져와야 할 레코드 건수가 많아지면 상당히 느려지는 방식)

**`ALL`**

- **풀 테이블 스캔** 접근 방식으로, **가장 비효율**적인 방법.
- **리드 어헤드(Read Ahead)**
    - 다른 DBMS와 같이 InnoDB도 풀 테이블 스캔이나 인덱스 풀 스캔과 같은 대량의 디스크 I/O를 유발하는 작업을 위해, 한 번에 여러 페이지를 읽어서 처리할 수 있음.
    - MySQL에서는 연속적으로 인접한 페이지가 연속해서 몇 번 읽히게 되면 백그라운드로 작동하는 읽기 스레드가 최대 한 번에 64개의 페이지씩 한꺼번에 디스크로부터 읽어 들이기 때문에 한 번에 페이지 하나씩 읽어 들이는 작업보다는 상당히 빠르게 레코드를 읽을 수 있다.
- **데이터웨어하우스나 배치 프로그램처럼 대용량의 레코드를 처리하는 쿼리에서 억지로 인덱스를 사용하는 쿼리보다 더 나은 접근 방법이 되기도 한다**.

일반적으로 index, ALL 접근 방법은 작업 범위를 제한하는 조건이 아니므로 빠른 응답을 사용자에게 보내 줘야 하는 웹 서비스 등과 같은 OLTP 환경에는 적합하지 않다.

### 6.2.5 **possbile_keys**

- 사용될 법했던 인덱스의 목록

### 6.2.6 **keys**

- **최종 선택된 실행 계획에서 사용하는 인덱스.**
- 쿼리를 튜닝할 때는 Key 칼럼에 의도했던 인덱스가 표시되는지 확인하는 것이 중요하다.

### 6.2.7 **key_len**

- 매우 중요한 정보 중 하나로, 쿼리를 처리하기 위해 다중 칼럼으로 만들어진 인덱스에서 몇 개의 칼럼까지 사용했는지 알려줌.
- 인덱스의 각 레코드에서 몇 바이트까지 사용했는지 알려주는 값.

### 6.2.8 **ref**

- 접근 방법이 ref이면 참조 조건 (Equal 비교 조건)으로 어떤 값이 제공됐는지 보여 준다

- **주의!**

    - ref 칼럼의 값이 **func**라고 표시되는 경우 참조값을 그대로 사용한 것이 아니라,
      콜레이션 변환이나 연산을 거쳐서 참조됐다는 것을 의미.
        - 문자 집합이 일치하지 않는 두 문자열 칼럼을 조인할 때
        - 숫자 타입의 칼럼과 문자열 타입의 칼럼으로 조인할 때

  → 따라서 되도록 조인 칼럼의 타입은 일치시키는 편이 좋다.

### 6.2.9 **rows**

- 실행 계획의 효율성 판단을 위해 **예측했던 레코드 건수**를 보여줌.
- 쿼리를 처리하기 위해 얼마나 많은 레코드를 디스크로부터 읽고 체크해야 하는지를 의미.
