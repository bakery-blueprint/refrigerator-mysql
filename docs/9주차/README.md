# 16장 베스트 프랙티스
다른 DBMS에는 있지만 MySQL에는없는 기능들과 자주 사용되지 않지만 비효율적일 수 밖에 없는 쿼리등을 살펴본다.

## 16.1 랜덤 정렬
랜점 정렬이란 기준을 아무것도 적용하지 않은 임의의 순서로 가져오는 것을 의미하기 때문에 쿼리를 실행할 때마다 다른 결과를 얻어야한다.
하지만 ORDER BY가 없더라도 DBMS에서 옵티마이저가 결정한 작업 순서대로 레코드를 가져오게 된다. 때문에 항상 동일한 결과를 반환한다.

### 16.1.1 지금까지의 구현
```sql
SELECT * FROM member
ORDER BY RAND()
LIMIT 1;
```
잘 동작하지만, 대용량 테이블에서 WHERE 조건이 없거나 WHERE 조건으로도 정렬 대상 건수를 많이 줄이지 못한다면 상당한 시간이 걸리는 쿼리가 된다.

### 16.1.2 인덱스를 이용한 임의 정렬
임의의 정렬이 필요한 테이블에 대해서 테이블을 생성할 때 임의의 값을 미리 부여하기 위한 새로운 컬럼을 추가하고 해당 값을 기준으로 정렬하여 쿼리하면 된다.

새로운 로우가 추가될 때 RAND() 함수를 사용하여 해당 컬럼 값에 임의의 값을 지정하고 저장하면 된다.

SELECT 쿼리를 할 때는 RAND() 값으로 WHERE 절으 기준 값을 생성하고 해당값을 기준으로 위아래로 원하는 크기만큼 구한 뒤 필요한 갯수만 읽어서 사용하면 된다.

## 16.2 페이징 쿼리
MySQL에서 페이징을 사용하기 위해선 LIMIT기능을 많이 사용하지만 인덱스를 사용한다고 하더라도 오프셋이 증가함에 따라 필요하지 않은 레코드까지 읽는 방식으로 동작하기 때문에 느려진다.

### 16.2.1 지금까지의 방법
```sql
SELECT *
FROM article WHERE board_id=1
ORDER BY article_id DESC LIMIT n, m;
```

### 16.2.2 불필요한 접근을 제거하기 위한 페이징 쿼리
페이징 쿼리를 실행할 때 프라이머리 키를 WHERE 절에 넣어주면 된다.

```sql
SELECT *
FROM article WHERE board_id=1 AND article_id>165 /* 이전 페이지의 가장 마지막 값*/
ORDER BY article_id DESC LIMIT n, m;
```

## 16.3 MySQL에서시퀸스 구현
RDBMS에서 일련번호를 발급하는 기능은 오라클의 시퀸스와 MySQL의 AUTO_INCREMENT가 있다.

시퀸스 : 테이블 의존적이지 않고 독립적으로 일련번호만 발급
AUTO_INCREMENT : 테이블에 종족된 일련번호 발급

시퀸스는 여러 테이블에 걸처 유일한 일련번호를 생성할 수 있지만, AUTO_INCREMENT는 그렇지 못한다.

현재까지 MySQL에서 시퀸스를 구현하는 방법은 테이블을 생성하고 그 테이블에 시퀸스의 현재 값을 유지하는 방법이다.

### 16.3.1 시퀸스룔 테이블 준비
시퀸스 값을 상당히 빈번히 읽어야 한다면 시퀸스 별로 나누는것이 좋다.

```sql
CREATE TABLE mysql_sequences (
	seq_name VARCHAR(10) NOT NULL,
	seq_curval BIGINT UNSIGNED NOT NULL,
	PRIMARY KEY (seq_name)
) ENGINE=MyISAM;
```

### 16.3.2 시퀸스를 위한 스토어드 함수
그냥 INSERT를 사용해도 되지만 이 기능을 스토어드 함수로 캡슐화해서 구현해두면 좋다.
```sql
DELIMITER ;;

CREATE FUNCTION nextval()
	RETURN BIGINT UNSIGNED
	MODIFIES SQL DATA
	SQL SECURITY INVOKER
BEGIN
	INSERT INTO mysql_sequences
		SET seq_name='DEFAULT', seq_curval=(@v_current_value:=1)
	ON DUPLICATE KEY
		UPDATE seq_curval=(@v_current_value:=seq_curval+1);

	RETURN @v_current_value;
END ;;
```

### 16.3.3 여러시퀸스 처리하기
여러 개의 시퀸스를 동시에 사용하려면 스토어드 함수가 시퀸스 이름을 인자로 받게하면 된다.

### 16.3.4 시퀸스 사용 시 주의사항
InnoDB와 같이 트랜잭션을 사용하는 스토리지 엔진을 사용하면 안된다. 시퀸스 테이블은 많은 클라이언트로부터 동시에 시퀸스 번호를 읽어야 할 수도 있다.

## 16.4 큰 문자열 칼럼의 인덱스(해시)
일반적으로 URL 정보는 인덱스를 생성하기에는 상당히 부담스러울 정도로 큰 데이터가 많다. 하지만 MyISAM이나 InnoDB 테이블의 인덱스는 하나의 레코드가 767바이트를 넘을 수 없다.

이럴때는 긴 문자열의 해시값으로 프라이머리 키나 유니크 인덱스를 생성하는 방법을 사용하면 쉽게 해결할 수 있다.

CRC32()는 4바이트, MD5()는 16바이트, SHA()는 20바이트의 해시값을 생성한다.

바이트의 크기가 크더라도 해시 충돌이 발생할 수 있기 때문에 실제 값을 비교하여 쿼리하는것이 좋다.

## 16.5 테이블 파티션
MySQL 5.1부터 파티션을 제공하지만 파티션 키가 숫자 타입으로 제한되어 있기 때문에 키 파티션 기능을 사용하여 키 타입에 제한 없이 파티션을 사용할 수 있다.

## 16.6 SNS 타임라인 구현
타임라인 기능에 RDBMS는 두 가지 측명에서 적합하지 않는 DB라고 볼 수 있다.
- RDBMS는 쓰기는 느리지만 읽기는 빠르게 처리하는 것이 장점이지만, 타임라인 기능은 읽기보다 쓰기의 비중이 훨씬 많다. 사용자 수나 관계가 늘어날 수록 더 심해진다.
- RDBMS의 정렬은 인덱스를 이용하지 못하면 정렬 대산 건수에 비례해 상당히 느려질 수 밖에 없는데, SNS의 타임라인 정렬은 인덱스를 이용할 수 없다.

이문제를 해결하기 위해 NoSQL이라는 쓰기위주의 DB가 출시되기 시작했다. 일반적으로 SNS 서비스는 사용자별로 데이터를 미리 정렬해서 중복 저장하는 방식으로 위의 문제점을 해결한다.

실시간으로 정렬을 하기에는 너무 느리고, 미리 타임라인을 위한 인덱스 테이블을 만들어 주기에는 너무 부담스럽다. 이를 Try & Fail 쿼리로 해결할 수 있다.

기준 시간을 기준으로 실시간으로 처리할 수 있는 만큼의 범위를 늘려가면서 쿼리한다. 각 범위에서 타임라인에 노출되는 갯수를 채우지 못하면 다음 범위를 더 조회한다.

## ~~16.7 MySQL표준설정~~
## ~~16.8 복제를 사용하지 않는 MySQ의 설정~~
## ~~16.9 MySQL복제 구축~~

## 16.10 SQL 작성 표준
- 조인 조건은 항상 ON 절에 기재
- 테이블 별칭 사용 및 칼럼 명에 테이블 별칭 포함
- 서버 사이드 프리페어 스테이트먼트 사용
    - 13.1.2절
- FULL GROUP BY 사용
    - 7.4.7절
- DELETE, UPDATE 쿼리에서 ORDER BY .. LIMIT .. 사용자제
- 문자열 리터럴 표기는 홑따옴표만 사용
- 서브쿼리는 조인으로 변경
- UNION [ALL]은 사용 자제
    - 내부적으로 임시 테이블을 만들게된다
- 스토어드 함수는 가능하면 DETERMINISTIC으로 정의
    - 11.3.3절
- 스토어드 프로그램에서는 예외 처리 코드를 작성
- UPDATE, DELETE 쿼리와 적용 건수 체크
- 숫자 값은 반드시 숫자 타입의 칼럼으로 정의

## 16.11 하드웨어와 플랫폼 선정
성능에 영향을 끼치는 순서
- RAID 컨트롤러
- 메모리
- 디스크
- CPU

## 16.12 백업 및 모니터링
MySQL이 오라클에 인수 되었어?
MySQL Enterprise backup을 사용할 수 잇지만 엔터프라이즈 라이센스가 있어야 사용할 수 있음..

## 16.12 스키마 검토
5.0 이상 버전에서 스키마 정보가 INFORMATION_SCHEMA라는 DB가 제공된다. 읽기 전용으로, 필수적으로 조인 키가 되는 컬럼의 타입이 일치하는지 여부를 확인해야 한다.

# 17장 응급처치
기본적인 장애에 대처하거나 사전에 예방하는 데 도움이 될 것이다.

## 17.1 서버 과부하
사용자 수가 급작스럽게 증가할 때는 대비하여 확장 가능한 구성으로 준비하는 것이 좋다.

### 17.1.1 운영체제의 유틸리티를 이용해 장비의 부하 확인
#### 시스템의 전체적인 부하 확인
uptime 명령어로 새당 서버의 CPU가 처리해야하는 작업이 얼마나 쌓였는지 알 수 있다.
```terminal
$ uptime
 12:16:50 up 30 days, 10:39, 1 user, load average: 3.34, 1.80, 0.59
```

vmstat은 초 단위로 가상 메모리의 상태를 보여주는 명령이지만, CPU나 프로세스 큐를 확인하는 용도로 더 많이 사용된다. CPU가어떤 작업을 주로 처리하고 있는지 보여주는데, 메모리나 스왑의 사용량도 보여주지만 다른 유틸로 더 쉽게 볼 수 있으므로, 'procs'와 'cpu'섹션을 주로 참고하면 된다.
```terminal
$ vmstat 1
procs ----------memory---------- ---swap-- -----io---- --system-- -----cpu------
...
```

#### 메모리 사용률
free 유틸을 통해 물리적 메모리와 스왑 영역의 메모리의 구분을 표시한다.

#### 디스크 사용량
isostat명령을 통해 디스크가 얼마나 사용되고 있는지 알 수 있다.

### 17.1.2 MySQL서버의 에러 로그 확인
서버에서 특별히 이상 징후나 에러가 발생하면 기본적으로 에러 로그에 기록하게 돼 있다. 

### 17.1.3 MySQL서버의 프로세스 리스트 확인
로그 파일에 문제가 없다면 로그인 상태를 확인하여 어떤 쿼리를 실행하고 잇는지, 어떤 프로세스가 특히 오랜 시간 동안 실행되는지 확인한다.

### 17.1.4 MySQL 서버의 최대 커넥션 설정 확인
사용자가 갑작스럽게 유입되면 커넥션을 더 생성 못하는 경우가 발생한다.

### 17.1.5 MySQL 서버의 슬로우 쿼리 분석
커넥션까지 확인햇다면 슬로우 쿼리를 확인하는 것이 좋다. 슬로우 쿼리 로그 설정을 통해 지정된 시간 이상 실행되는 쿼리를 별도의 로그 파일로 기록할 수 있다.

### 17.1.6 쿼리의 실행 빈도 확인
MySQL Enterprise Monitor 같은 모니터링 툴이 있다면 서버에서 초당 처리되는 쿼리의 수를 확인 할 수 있다.

###  17.1.7 각 원인별 조치
- 튜닝되지 않은 쿼리 : 부하가 높은 쿼리부터 튜닝한다
- 잘못 사용된 쿼리 : 다른 서비스 쿼리에 영향을 미치는 트랜젝션을 찾아 종료한다.
- 실제 사용자가 많은 경우 : 서버를 증설하여 부하를 줄이거나 로그 동기화 방식이나 트랜잭션 커밋 방식을 바꿔 느슨하게 동작하도록 수정한다.

## 17.2 MySQL 서버 셧다운
별도의 플러그인이나 하드웨어 장애로 인해 MySQL 서버가 종료될 수 있다. 세그멘테이션 폴트 메세지등의 에러로그를 확인해야한다.

## ~~17.3 MySQL 복구~~

## 17.4 테이블 메타 정보의 불일치
ALTER, RENAME 등의 명령으로 테이블 구조를 변경하는 작업은 가끔 트랜잭션을 보장하지 못할 때가 있다. 때문에 부하가 높은 시점에서 테이블의 스키마 변경이나 테이블명 변경등의 명령은 사용하지 않는 것이 좋다.

## 17.5 복제가 멈췄을 때
마스터의 복제가 진행되지 않는 경우가 발생할 때 슬레이브 서버를 서비스에서 사용한다면 문제가 될 수 있다. 

복제를 위해 사용되는 SQL 스레드와 IO 스레드를 슬레이브에서 확인하는 것이 좋다.

## 17.6 경고 메시지로 메러 로그 파일이 커질 때
설정을 통해 서버에 로그가 쌓이지 않게 할 수 있다.

## 17.7 바이너리 로그로 디스크가 꽉 찬 경우
마스터 서버에선 복제를 위해 바이너리 로그를 기록한다. 일정 기간이 지난 후 삭제 되도록 설정하고 임의로 지우는 경우 직접 파일에 접근하지 말고 특정 명령어를 사용해야한다.

## 17.8 마스터 MySQL 서버에서함수 생성 오류
데이터를 변경하는 SQL 문장이 포함된 경우 "DERTERMINISTIC", "NO SQL", "READ SQL DATA" 옵션 중 하나가 정의되었을때만 정상적으로 동작한다.

## 17.9 MySQL의 DB명 변경
DB 명의 변경은 지원하지 않고, 테이블을 다른 DB로 옮기는 것이 최선이다.

## 17.10 DB의 테이블 생성 DDL만 덤프
테이블이나 스토어드 프로시저 같은 스키마만 옮기는 경우 mysqldump를 이용하면 된다.

## 17.11 mysqldump의 결과를 다른 이름의 DB로 적재
mysqldump 로 덤프 파일을 만들어 다른 DB에서 SOURCE로 실행한다.

## 17.12 테이블이나 레코드의 잠금 해결
풀리지 않는 트랜젝션으로 인한 문제는 4.3절 (MyISAM)과 4.4.5절 (InnoDB)를 통해 해결한다.

## 17.13 InnoDB의 잠금 대기 시간 초과
트랜젝션이 걸린 상태에서 다른 트랜젝션이 일정 시간 이상으로 기다리게 되면 그 쿼리는 실패한다.

## 17.14 MySQL 서버의 호스트 잠금
클라이언트 별로 발생한 에러의 카운터를 가지고 있다. 호스트별 에러 카운터 값이 설정 변수를 초과하는 경우 접속을 차단한다. 

각 클라이언트 에러 카운트를 초기화하거나, max_connect_errors 시스템 변수를 증가시켜 설정하면 된다.