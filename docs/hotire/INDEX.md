# Index 

DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. 인덱스를 역할로 구분해본다면 PK와 보조 키로 구분할 수 있다.

- PK : 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스

- 보조키 : PK를 제외한 나머지 모든 인덱스
PK를 제외한 나머지 모든 인덱스는 보조 인덱스라고 분류한다, 유니크 인덱스는 PK와 성격이 비슷하고 PK를 대체해서 사용할 수 있다고
해서 대체 키라고도 하는데, 별도로 분류하기도 하고 그냥 보조 인덱스로 분류하기도 한다.

대표적으로 B-Tree 인덱스와 Hash 인덱스를  사용한다.

- 유니크 인덱스의 경우 1건만 찾으면 더 찾지 않아도 되기 때문에 옵티마이저 최적화에 도움이 된다. 

## B-Tree 

B-Tree의 "B"는 Binary의 약자가 아니라 Balanced를 의미한다.

B-Tree는 트리 구조로 되어있다.  트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간의 노드를 "브렌치 노드"라고 한다. 

데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있다.

### B-Tree 인덱스 키 추가 및 삭제

- 인덱스 키 추가 : B-Tree에 저장될 때는 저장될 키 값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. 
저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. 
만약 리프 노드가 꽉 차서 더는 저장할 수 없을 떄는 리프 노드가 분리돼야 하는데, 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 
이러한 탓에 B-Tree는 상대적으로 쓰기 작업(새로운 키를 추가 하는 작업)에 비용이 많이 드는 것으로 알려졌다.

- 인덱스 추가로 인해 INSERT나 UPDATE 문장이 어떤 영향을 받을까? : 테이블의 칼럼 수, 칼럼의 크기, 인덱스 칼럼의 특성 등을 확인해야 한다

대략적으로 계산하는 방법은 테이블에 레코드를 추가하는 작업 비용을 1이라고 가정하면 해당 테이블의 인덱스에 키를 추가하는 작업 비용을 1~1.5 정도로 예측하는 것이 일반적이다. 
일반적으로 테이블에 인덱스가 3개(테이블의 모든 인덱스가 B-Tree라는 가정하에)가 있다면 이때 테이블에 인덱스가 하나도 없는 경우 작업 비용이 1이고, 
3개인 경우에는 5.5 정도의 비용(1.5 * 3 + 1)정도로 예측해 볼 수 있다. 중요한 것은 이 비용의 대부분이 메모리와 CPU에서 처리하는 시간이 아니라 디스크로부터 인덱스 페이지를 읽고 쓰기를 해야 하기 때문에 시간이 오래 걸린다는 것이다.

InnoDB 스토리지 엔진은 적절하게 인덱스 키 추가 작업을 지연시켜 나중에 처리할지, 아니면 바로 처리할지 결정한다.

1. 사용자의 쿼리 실행
2. InnoDB 버퍼 풀에 새로운 키 값을 추가해야 할 페이지(B-Tree의 리프 노드)가 존재한다면 즉시 키 추가 작업 처리
3. 버퍼 풀에 B-Tree의 리프 노드가 없다면 인서트 버퍼에 추가할 키 값과 레코드의 주소를 임시로 기록해 두고 작업 완료(사용자의 쿼리는 실행 완료됨)
4. 백그라운드 작업은 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야 할 인덱스 키값이 있는지 확인한 후, 있다면 병합함(B-Tree에 인덱스 키와 주소를 저장)
5. 데이터베이스 서버 자원의 여유가 생기면 MySQL 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키와 주소 값을 머지(B-Tree에 인덱스 키와 주소를 저장)시킴

-> 체인지 버퍼링이라고한다. 관련 설정 파라미터로 innodb_chanage_buffering가 있다

버퍼에 의해 인덱스 키 추가 작업이 지연되어 처리된다 하더라도, 이는 사용자에게 아무런 악영향 없이 투명하게 처리되므로 개발자는 이를 신경쓰지 않아도 된다. innodb_chanage_buffering설정 값을 이용해 키 추가 작업과 키 삭제 작업 중 어느 것을 지연처리할지 설정해야 한다.

- 인덱스 키 삭제

해당 키 값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만하면 작업이 완료된다. 이렇게 삭제 마키된 인덱스 키 공간은 계속 그대로 방치하거나 또는 재활용할 수 있다. 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스크 I/O가 필요한 작업이다.

- 인덱스 키 변경

인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키값이 변경되는 경우에는 단순히 인덱스상의 키값만 병경하는 것은 불가능하다. B-Tree의 키값 변경 작업은 먼저 키값을 삭제한 후, 다시 새로운 키값을 추가하는 형태로 처리된다.

- 인덱스 키 검색

INSERT, UPDATE, DELETE 작업을 할 떄 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 바로 빠른 검색을 위해서다.


### 인덱스 키값의 크기

인덱스의 페이지 크기(16KM)와 키 값의 크기의 따라 B-tree의 자식 노드의 개수가 결정된다.

만약 12바이트의 키 값을 갖는다면 16*1024/(16+12) = 585 개수의 자식 노드를 갖는다.


### 옵티마이저 인덱스 판단 

일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 더 비용이 많이 드는 작업인 것으로 예측한다.

즉, 전체 테이블 레코드에 20%~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을모두 읽어서 필요한 레코드만 가려내는(필터링) 방식으로 처리하게 된다.

-> 그래도 힌트로 인덱스르 주어보자. 빨라질수 있다.


- https://junghyungil.tistory.com/m/137


## 인덱스 팁

- https://jojoldu.tistory.com/243

## 클러스터링 인덱스 

- https://enterone.tistory.com/230
- https://kosaf04pyh.tistory.com/m/293



 
 